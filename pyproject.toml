[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "netcheck"
version = "1.0.0"
description = "A comprehensive network interface analysis tool for GNU/Linux"
readme = "README.md"
requires-python = ">=3.12"
license = {text = "AGPL-3.0-or-later"}
authors = [{name = "Sascha"}]
dependencies = []

[project.urls]
Homepage = "https://github.com/Sascha-1/netcheck"
Repository = "https://github.com/Sascha-1/netcheck"

# ============================================================================
# Pytest Configuration
# ============================================================================

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "-v",
    "--strict-markers",
    "--strict-config",
    "--tb=short",
    "--cov=.",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-branch",
]
markers = [
    "slow: marks tests as slow",
    "integration: marks tests as integration tests",
]

# ============================================================================
# Coverage Configuration
# ============================================================================

[tool.coverage.run]
source = ["."]
omit = [
    "*/__pycache__/*",
    "*/venv/*",
    "*/env/*",
    "*/.venv/*",
    "cleanup.sh",
    "cleanup.py",
]
branch = true

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "@abstractmethod",
]
precision = 2
show_missing = true

[tool.coverage.html]
directory = "htmlcov"

# ============================================================================
# Mypy Configuration
# ============================================================================

[tool.mypy]
python_version = "3.12"

# Strict mode - enforced everywhere, no overrides
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_any_generics = true
disallow_subclassing_any = true
disallow_untyped_calls = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
show_error_codes = true
show_error_context = true
pretty = true

# Scan everything recursively (like pytest does)
# Just specify "." to scan all .py files in the project
# This is simpler than listing every file individually
files = ["."]

# Exclude patterns for files/directories to skip
exclude = [
    "^build/",
    "^dist/",
    "^\\.venv/",
    "^venv/",
    "^env/",
    "^\\.mypy_cache/",
    "^\\.pytest_cache/",
]

# No per-module overrides - strict rules apply everywhere

# ============================================================================
# Pylint Configuration  
# ============================================================================

[tool.pylint.main]
# Use all available CPUs for parallel processing
jobs = 0

# Python version
py-version = "3.12"

# Analyze all Python files recursively
recursive = true

# Ignore patterns (match mypy/pytest)
ignore-paths = [
    "^build/.*$",
    "^dist/.*$",
    "^\\.venv/.*$",
    "^venv/.*$",
    "^env/.*$",
    "^\\.mypy_cache/.*$",
    "^\\.pytest_cache/.*$",
    "^htmlcov/.*$",
    "^__pycache__/.*$",
]

[tool.pylint.messages_control]
# Disable specific warnings that conflict with our coding style or are too noisy
disable = [
    # Docstring warnings (we have docstrings where meaningful)
    "missing-module-docstring",
    "missing-class-docstring", 
    "missing-function-docstring",
    
    # Design warnings (sometimes legitimate to violate)
    "too-few-public-methods",      # Dataclasses/DTOs often have few methods
    "too-many-arguments",          # Some functions legitimately need many args
    "too-many-locals",             # Complex functions may need many locals
    "too-many-branches",           # Detection logic has many branches
    "too-many-statements",         # Some functions are legitimately complex
    
    # Naming warnings (allow flexible naming)
    "invalid-name",                # Allow short names like 'e', 'i', 'f'
    
    # Code duplication (some similarity acceptable in tests)
    "duplicate-code",
    
    # Access warnings (we use _private functions intentionally)
    "protected-access",            # Allow calling _private functions in same package
    
    # Style warnings (handled by other tools)
    "line-too-long",               # Handled by black (100 char limit)
    "unnecessary-pass",            # Sometimes needed for clarity
    
    # Import warnings (allow flexibility)
    "wrong-import-order",          # isort handles this
    "ungrouped-imports",           # isort handles this
    
    # Exception warnings (sometimes we need broad catching)
    "broad-except",                # Sometimes catching Exception is appropriate
    "broad-exception-caught",      # Sometimes catching Exception is appropriate
]

[tool.pylint.format]
# Maximum line length (match black/mypy)
max-line-length = 100

# Allow common short variable names
good-names = [
    "i", "j", "k",           # Loop counters
    "e", "ex",               # Exceptions
    "f", "fp",               # Files
    "db", "id",              # Common abbreviations
    "ip", "v4", "v6",        # Network-specific
    "_",                     # Unused variables
]

[tool.pylint.design]
# Complexity thresholds (reasonable but not too strict)
max-args = 10              # Maximum function arguments
max-attributes = 15        # Maximum class attributes
max-bool-expr = 6          # Maximum boolean expressions
max-branches = 20          # Maximum branches in a function
max-locals = 25            # Maximum local variables
max-returns = 8            # Maximum return statements
max-statements = 80        # Maximum statements in a function

[tool.pylint.basic]
# Docstring requirements (require only for public API)
no-docstring-rgx = "^_|^test_"  # Don't require docstrings for private/test functions

# Allow TODO/FIXME comments
notes = ["FIXME", "XXX"]  # Don't warn about TODO

[tool.pylint.similarities]
# Duplicate code detection
min-similarity-lines = 10  # Minimum lines to trigger duplicate warning
ignore-comments = true
ignore-docstrings = true
ignore-imports = true
ignore-signatures = true

[tool.pylint.typecheck]
# Don't warn about dynamically generated members
generated-members = ["pytest.*", "mock.*", "MagicMock.*"]

[tool.pylint.imports]
# Import preferences
allow-wildcard-with-all = false
preferred-modules = []

[tool.pylint.exceptions]
# Exception handling
overgeneral-exceptions = ["builtins.BaseException"]  # Only BaseException is too broad

[tool.pylint.logging]
# PEP 391 Compliant Logging Configuration
# =========================================
# 
# PEP 391 recommends LAZY EVALUATION for logging using % style formatting.
# This provides significant benefits:
#
# 1. PERFORMANCE: Arguments are NOT evaluated if log level is disabled
#    Example: logger.debug("Processing %d items", expensive_count())
#    If DEBUG is disabled, expensive_count() is never called
#
# 2. STRUCTURED LOGGING: Better integration with logging aggregation tools
#    (Splunk, ELK, etc.) which can parse % style format strings
#
# 3. MEMORY EFFICIENCY: String formatting only happens when message is logged
#
# CORRECT (PEP 391 compliant):
#   logger.debug("Found %d interfaces: %s", len(interfaces), ", ".join(interfaces))
#   logger.info("Processing interface %s with IP %s", name, ip)
#   logger.error("Failed to connect to %s:%d", host, port)
#
# INCORRECT (current codebase style - should be migrated):
#   logger.debug(f"Found {len(interfaces)} interfaces: {', '.join(interfaces)}")
#   logger.info(f"Processing interface {name} with IP {ip}")
#   logger.error(f"Failed to connect to {host}:{port}")
#
# MIGRATION PLAN:
# The current codebase uses f-strings in logging. To maintain backwards compatibility
# during migration, this is set to "old" to encourage proper lazy formatting for new code.
# Existing code should be gradually migrated from f-strings to % formatting.

# Use "old" (%) style for PEP 391 compliance and lazy evaluation
logging-format-style = "old"

# Specify which modules provide logging functionality
logging-modules = ["logging"]

[tool.pylint.miscellaneous]
# Don't warn about TODO comments
notes = []

[tool.pylint.refactoring]
# Refactoring suggestions (keep reasonable ones)
max-nested-blocks = 6      # Maximum nested block depth
never-returning-functions = ["sys.exit", "argparse.ArgumentParser.error"]
